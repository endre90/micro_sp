use std::{
    collections::HashSet,
    time::{Duration, Instant},
};

use crate::{Predicate, State, Transition};

#[derive(PartialEq, Eq, Clone, Debug, PartialOrd, Ord, Default)]
pub struct PlanningResult {
    pub found: bool,
    pub length: usize,
    pub plan: Vec<String>,
    pub time: Duration,
}

/**
 *  The following dosctring was generated by ChatGPT!
 * 
 *  The function `bfs_transition_planner` takes in four arguments:
 *   - `state`: a `State` object representing the current state of the system
 *   - `goal`: a `Predicate` object representing the goal state
 *   - `model`: a vector of `Transition` objects representing the possible actions that can be taken in the system
 *   - `max_depth`: an `usize` value representing the maximum depth of the search
 *
 *  It returns a `PlanningResult` object, which contains the following fields:
 *   - `found`: a `bool` indicating whether a plan was found to reach the goal state
 *   - `length`: an `usize` value representing the length of the plan found
 *   - `plan`: a vector of `String` objects representing the actions in the plan
 *   - `time`: a `Duration` object representing the time taken to find the plan
 *
 *  The function uses a Breadth-First Search (BFS) algorithm to search for a plan to reach the goal state. It starts by initializing a `visited` set to keep track of states that have been visited and a `stack` to hold the states and actions that need to be explored. It then enters a loop that continues until the `stack` is empty.
 *
 *  In each iteration, the function checks the length of the `stack`. If it is empty, the function breaks and returns a default `PlanningResult` object with `found` set to `false`. If the `stack` is not empty, the function pops the top state and actions from the stack and checks if the goal state is reached by evaluating the `goal` predicate on the current state. If the goal state is reached, the function breaks and returns a `PlanningResult` object with `found` set to `true`, `length` set to the length of the path, `plan` set to the path, and `time` set to the elapsed time since the start of the function.
 *
 *  If the goal state is not reached, the function then checks if the search has exceeded the maximum depth. If it has, the function breaks and returns a default `PlanningResult` object with `found` set to `false`. If the maximum depth has not been exceeded, the function then checks if the current state has been visited before. If it has, the function continues to the next iteration. If the current state has not been visited before, the function inserts the current state into the `visited` set and then iterates through each transition in the `model`. For each transition, the function checks if it is valid in the current state by evaluating the transition's `eval_planning` function on the current state. If the transition is valid, the function applies the transition to the current state to get the next state, adds the transition's action to the path, and then pushes the next state and the updated path to the front of the stack.
 */
pub fn bfs_transition_planner(
    state: State,
    goal: Predicate,
    model: Vec<Transition>,
    max_depth: usize,
) -> PlanningResult {
    let now = Instant::now();
    let mut visited: HashSet<State> = HashSet::new();
    let mut stack: Vec<(State, Vec<String>)> = vec![(state, vec![])];
    loop {
        match stack.len() {
            0 => {
                break PlanningResult {
                    found: false,
                    ..Default::default()
                }
            }
            _ => {
                let (s, path) = stack.pop().unwrap();
                match goal.clone().eval(&s) {
                    true => {
                        break PlanningResult {
                            found: true,
                            length: path.len(),
                            plan: path,
                            time: now.elapsed(),
                        }
                    }
                    false => match path.len() > max_depth {
                        true => {
                            break PlanningResult {
                                found: false,
                                ..Default::default()
                            }
                        }
                        false => match visited.contains(&s) {
                            true => continue,
                            false => {
                                visited.insert(s.clone());
                                model
                                    .iter()
                                    .for_each(|t| match t.clone().eval_planning(&s) {
                                        false => (),
                                        true => {
                                            let next_s = t.clone().take_planning(&s);
                                            let mut next_p = path.clone();
                                            next_p.push(t.name.clone());
                                            stack.insert(0, (next_s, next_p));
                                        }
                                    })
                            }
                        },
                    },
                }
            }
        }
    }
}
